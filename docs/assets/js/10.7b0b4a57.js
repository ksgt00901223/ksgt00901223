(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{337:function(a,t,s){"use strict";s.r(t);var r=s(1),e=Object(r.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("div",{staticClass:"content"},[s("h2",{attrs:{id:"两数之和"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#两数之和","aria-hidden":"true"}},[a._v("#")]),a._v(" 两数之和")]),a._v(" "),s("h3",{attrs:{id:"题干："}},[s("a",{staticClass:"header-anchor",attrs:{href:"#题干：","aria-hidden":"true"}},[a._v("#")]),a._v(" 题干：")]),a._v(" "),s("p",[s("strong",[a._v("给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。")])]),a._v(" "),s("p",[s("strong",[a._v("你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。")])]),a._v(" "),s("h3",{attrs:{id:"示例"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#示例","aria-hidden":"true"}},[a._v("#")]),a._v(" 示例:")]),a._v(" "),s("p",[s("em",[a._v("给定 nums = [2, 7, 11, 15], target = 9\n因为 nums[0] + nums[1] = 2 + 7 = 9\n所以返回 [0, 1]")])]),a._v(" "),s("h3",{attrs:{id:"思路："}},[s("a",{staticClass:"header-anchor",attrs:{href:"#思路：","aria-hidden":"true"}},[a._v("#")]),a._v(" 思路：")]),a._v(" "),s("p",[a._v("一开始想双重循环应该是最容易想到的，但是想换种想法，因为根据题干可以确定答案是唯一，所以只要吧 target 与数组的项做差，然后看差是不是还在这个项后面的项里就行了。")]),a._v(" "),s("h3",{attrs:{id:"过程："}},[s("a",{staticClass:"header-anchor",attrs:{href:"#过程：","aria-hidden":"true"}},[a._v("#")]),a._v(" 过程：")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("var twoSum = function (nums, target) {\n    let arr = [];\n    for (let i = 0; i < nums.length; i++) {\n        const t = target - nums[i], arr2=nums.slice(i+1);\n        if (arr2.indexOf(t)!=-1) {\n            arr = [i,arr2.indexOf(t)+i+1];\n            break;\n        }\n    }\n    return arr;\n};\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br"),s("span",{staticClass:"line-number"},[a._v("11")]),s("br")])]),s("h3",{attrs:{id:"坑："}},[s("a",{staticClass:"header-anchor",attrs:{href:"#坑：","aria-hidden":"true"}},[a._v("#")]),a._v(" 坑：")]),a._v(" "),s("ol",[s("li",[a._v("当遇到[3,1] 6，[3,3,1] 6,这些组合因为 6-3=3，但是如果只看数组是否包含 3 就不行了，一是可能是重复的那一项，同样因为我用的 indexOf 所以遇到出现两次 3 也不靠谱，所以我把数组分割了，只对未循环的部分进行查找，一旦找到就跳出循环。")]),a._v(" "),s("li",[a._v("在 LeetCode 测试时显示超出输出限制，然后我把里面的各种 console.log 删除掉就 ok 了（我还特意把出错的数组自己测试一下，发现结果并没错）。")])])])}],!1,null,null,null);t.default=e.exports}}]);