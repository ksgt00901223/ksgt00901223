(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{322:function(s,t,n){"use strict";n.r(t);var e=n(1),a=Object(e.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var s=this,t=s.$createElement,n=s._self._c||t;return n("div",{staticClass:"content"},[n("h2",{attrs:{id:"读《算法导论》第2章-算法基础-2-3设计算法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#读《算法导论》第2章-算法基础-2-3设计算法","aria-hidden":"true"}},[s._v("#")]),s._v(" 读《算法导论》第2章-算法基础--2-3设计算法")]),s._v(" "),n("p",[s._v("###2.3.1分治法\n开头讲了很多算法的结构都是递归，而这些算法遵循"),n("strong",[s._v("分治法")]),s._v("的思想，也就是将问题分解为跟原问题差不多的子问题，然后递归求解，在合并来建立原问题的解。\n分治模式在每层递归都有三个步骤：\n1.分解原问题为若干子问题，这些子问题是原问题的规模较小的实例。\n2.解决这些子问题，递归求解各子问题。然而若子问题的规模足够小，则直接求解。\n3.合并这些子问题的解成原问题的解。\n然后说了归并排序法遵循分治模式，反正看到这我还是一头雾水，直到我看完给的例子。\n书里讲了归并递归的例子，通俗的说有一个数组，这数组可以从某处切开，然后切开的两部分恰好是排好序的（一开始我就想吐槽这，怎么就排好序了），不过要想弄清就不要先管它怎么拍的。\n还是以扑克牌的例子，假设有两堆牌，每一堆都是已经排好序的，A：[2,3,5,8,10]，B：[4,7,9,J,Q,K,A]，我们先把两堆牌的第一张A:2，B：2，拿来比较，然后把较小的一张（相等就哪个都行）放到一边，比如这里面是A的2，那么就把它放到C：[2]，然后我们拿出A的第二张继续跟B的第一张比，然后再这样把小的放到C里，依次进行下去，就像两队PK，一般都是菜的先上，一个下了下一个补上，输了的就去饮水机那最冷板凳吧，最终做冷板凳的顺序就是两个战队的队员的水平排序。\n如果双方比较时其中一方已经没有了，那么另一方直接补到C处就可以了，因为这两方都是已经排好序的，所以剩下的也就没必要排了。\n上面的例子就是合并，将子问题的解合并为原问题的解，那么如何获得两个已经排好序的数组呢，我们把每个数组在分成两个数组，如果数组元素的个数还能继续分，直到都落单。\n网上找到一张图很清晰明了：\n"),n("img",{attrs:{src:"https://upload-images.jianshu.io/upload_images/9910329-889661991543a606.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/400",alt:"分治法.jpg"}})]),s._v(" "),n("p",[s._v("分分合合，最后大一统。\n最后上代码：")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("//合\nconst merge = (left, right) => {\n    //定义一个空数组用来保存排序后的内容，ij用来指示是左右两部分的某个元素\n\tlet result = [],\n\t\ti = 0,\n        j = 0;\n    //如果i或j等于left或right的长度的话，意味着那个数组已经被全部放进result了\n\twhile (i < left.length && j < right.length) {\n\t\tif (left[i] <= right[j]) {\n            //下面两行代码也可以写成result.push(left[i++])\n\t\t\tresult.push(left[i]);\n\t\t\ti += 1;\n\t\t} else {\n\t\t\tresult.push(right[j]);\n\t\t\tj += 1;\n\t\t}\n    }\n    //如果其中一个数组已经被全部放进result里，那么只需要把另一个依次push进result就好了，因为两个数组都是排好序的\n\twhile (i < left.length) {\n\t\tresult.push(left[i]);\n\t\ti += 1;\n\t}\n\twhile (j < right.length) {\n\t\tresult.push(right[j]);\n\t\tj += 1;\n\t}\n\treturn result;\n};\n//将数组分成两部分，然后进行合操作（也就是merge函数）\nconst mergeSortRec = arr => {\n    let length = arr.length;\n    //如果被排数组长度是1，那么就直接返回它\n\tif (length === 1) {\n\t\treturn arr;\n\t}\n\tlet mid = Math.floor(length / 2),\n\t\tleft = arr.slice(0, mid),\n\t\tright = arr.slice(mid, length);\n\treturn merge(mergeSortRec(left), mergeSortRec(right));\n};\nlet arr = [2, 5, 1, 8, 4, 20, 6, 8, 111, 7, 9];\nconsole.log(mergeSortRec(arr));//[ 1, 2, 4, 5, 6, 7, 8, 8, 9, 20, 111 ]\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br"),n("span",{staticClass:"line-number"},[s._v("29")]),n("br"),n("span",{staticClass:"line-number"},[s._v("30")]),n("br"),n("span",{staticClass:"line-number"},[s._v("31")]),n("br"),n("span",{staticClass:"line-number"},[s._v("32")]),n("br"),n("span",{staticClass:"line-number"},[s._v("33")]),n("br"),n("span",{staticClass:"line-number"},[s._v("34")]),n("br"),n("span",{staticClass:"line-number"},[s._v("35")]),n("br"),n("span",{staticClass:"line-number"},[s._v("36")]),n("br"),n("span",{staticClass:"line-number"},[s._v("37")]),n("br"),n("span",{staticClass:"line-number"},[s._v("38")]),n("br"),n("span",{staticClass:"line-number"},[s._v("39")]),n("br"),n("span",{staticClass:"line-number"},[s._v("40")]),n("br"),n("span",{staticClass:"line-number"},[s._v("41")]),n("br"),n("span",{staticClass:"line-number"},[s._v("42")]),n("br")])]),n("p",[s._v("以上代码参考《学习JavaScript数据结构与算法》第10章归并排序。")]),s._v(" "),n("p",[s._v("###2.3.2分析分治算法\n没看懂，以后补")])])}],!1,null,null,null);t.default=a.exports}}]);